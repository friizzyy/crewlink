# CrewLink Security & Authentication Audit

## Table of Contents
1. [Authentication Architecture](#authentication-architecture)
2. [Session Management](#session-management)
3. [Role-Based Access Control (RBAC)](#role-based-access-control-rbac)
4. [Environment Variables Audit](#environment-variables-audit)
5. [Password Security](#password-security)
6. [Data Isolation & Privacy](#data-isolation--privacy)
7. [API Route Authorization](#api-route-authorization)
8. [Prisma Query Security](#prisma-query-security)
9. [JWT Configuration Review](#jwt-configuration-review)
10. [Sensitive Data Handling](#sensitive-data-handling)
11. [Development/Production Checks](#developmentproduction-checks)
12. [OWASP Top 10 CrewLink-Specific Checks](#owasp-top-10-crewlink-specific-checks)
13. [Third-Party Integration Security](#third-party-integration-security)
14. [Incident Response & Logging](#incident-response--logging)
15. [Security Checklist](#security-checklist)

---

## Authentication Architecture

### Overview
CrewLink uses **NextAuth.js v4** with a credentials-based authentication flow. The system combines email/password authentication with Prisma ORM for session/account persistence and bcryptjs for password hashing.

### Authentication Flow

```
User Input (email/password)
    ↓
NextAuth CredentialsProvider
    ↓
bcryptjs.compare() against DB password_hash
    ↓
JWT token generation (lib/auth.ts)
    ↓
PrismaAdapter stores session in database
    ↓
User session available in API routes + client via useSession()
```

### NextAuth Configuration Location
- Primary config: `lib/auth.ts`
- Next.js route handler: `app/api/auth/[...nextauth]/route.ts`

### Key Configuration Elements to Audit

**1. CredentialsProvider Setup:**
```typescript
// VERIFY in lib/auth.ts:
// - authorize() function compares plaintext password against bcryptjs hash
// - Returns user object with id, email, name, role (NOT password hash)
// - No credentials stored in JWT
// - Callback error handling (no error message leakage)
```

**2. JWT Configuration:**
- Signing algorithm: Verify using HS256 or RS256 (not "none")
- Secret length: NEXTAUTH_SECRET must be minimum 32 characters
- Expiration: Configure reasonable session lifetime (typically 30 days for "remember me", 24h default)
- Encryption enabled: Check maxAge and refresh token flow

**3. PrismaAdapter:**
- Handles Session, Account, and VerificationToken models
- Session tokens are cryptographically random
- Automatic cleanup of expired sessions via Prisma
- Check SessionExpiration TTL configuration

---

## Session Management

### Session Storage
Sessions are stored in the **sessions** table (Prisma models):
```prisma
model Session {
  id            String    @id @default(cuid())
  sessionToken  String    @unique
  userId        String
  expires       DateTime
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}
```

### Session Token Security
- Tokens are cryptographically random (generated by NextAuth)
- Stored in HTTP-only cookies (prevents XSS access)
- Secure flag set in production (HTTPS only)
- SameSite=Lax to prevent CSRF

### Audit Checks

**1. Cookie Configuration:**
```bash
# Verify in lib/auth.ts or route handler:
# - httpOnly: true (prevents JavaScript access)
# - secure: true (HTTPS only in production)
# - sameSite: 'lax' or 'strict'
# - path: '/' (accessible site-wide)
# - maxAge: Set to reasonable value (default 30 days)
```

**2. Session Expiration:**
- Expired sessions must be cleaned up from database
- Verify Prisma cleanup job (consider scheduled task if manual)
- Stale sessions should not be reusable after expiration

**3. Concurrent Session Limits:**
- Current implementation allows multiple concurrent sessions per user
- Consider implementing single-device-per-user if security requirement
- If allowing multiple sessions, implement logout-all functionality

### Session Queries to Audit
```bash
# Search for session queries:
grep -r "session\|sessions" app/api --include="*.ts" --include="*.tsx"
grep -r "getServerSession\|useSession" --include="*.ts" --include="*.tsx"

# Verify all protected routes use:
const session = await getServerSession(authOptions)
if (!session) return NextResponse.json({}, { status: 401 })
```

---

## Role-Based Access Control (RBAC)

### Role System Overview
CrewLink implements a two-role system:
- **hirer**: Posts jobs, makes payments, manages hired workers
- **worker**: Applies for jobs, submits bids, performs work

### User Role Model
```prisma
model User {
  id        String    @id @default(cuid())
  email     String    @unique
  password  String    // bcryptjs hash, never in JWT
  name      String
  role      String    // 'hirer' | 'worker'
  phone     String?
  avatarUrl String?
  // ... other fields
}
```

### Role-Based Route Protection

**Client-Side Protection (RoleGuard Component):**
```typescript
// Location: components/RoleGuard.tsx (or similar)
// VERIFY:
// - Checks session.user.role matches required role(s)
// - Redirects unauthenticated users to /sign-in
// - Redirects unauthorized roles to /select-role or home
// - Server-side checks are REQUIRED (client checks alone insufficient)
```

**Protected Routes:**
- `/hiring/*`: Accessible only to users with role='hirer'
- `/work/*`: Accessible only to users with role='worker'
- `/select-role`: Accessible to authenticated users without assigned role
- `/dashboard`: Role-specific dashboard (different for hirer vs worker)

### Role-Based API Protection

**Hirer-Only Endpoints:**
- `POST /api/jobs`: Create job posting
- `PATCH /api/jobs/[id]`: Edit job details
- `DELETE /api/jobs/[id]`: Remove job posting
- `POST /api/jobs/[id]/hire`: Accept worker bid and initiate payment

**Worker-Only Endpoints:**
- `POST /api/bids`: Submit bid on job
- `GET /api/work/my-bids`: View own bids
- `PATCH /api/profile/worker-info`: Update worker profile/skills

**Audit Checks:**
```bash
# Search for role checks in API routes:
grep -r "session.user.role" app/api --include="*.ts"

# Expected pattern:
# if (session.user.role !== 'hirer') return NextResponse.json({}, { status: 403 })

# Verify no hardcoded role checks (use constants):
grep -r "'hirer'\|'worker'" app/api --include="*.ts" \
  | grep -v "const ROLE_\|enum Role"
# These should only appear in constants/enums, not scattered in code
```

### Role Switching Prevention
- Once a user selects a role (hirer or worker), role change should require admin intervention
- Client-side toggle (`NEXT_PUBLIC_ENABLE_ROLE_TOGGLE`) is QA/dev only
- **Production must have this set to `false`**
- Verify role immutability in production code

```bash
# Verify NEXT_PUBLIC_ENABLE_ROLE_TOGGLE is false in production:
grep -r "ENABLE_ROLE_TOGGLE" --include="*.ts" --include="*.tsx" --include=".env*"

# Should NOT exist in production .env files or should be explicitly false
```

---

## Environment Variables Audit

### Critical Variables (Never Commit)

**1. NEXTAUTH_SECRET**
- Used to sign JWT tokens
- Must be at least 32 characters (256 bits recommended)
- Should be cryptographically random
- Never commit to version control

```bash
# Verify length and secrecy:
echo $NEXTAUTH_SECRET | wc -c  # Must be > 32

# Check .gitignore:
grep ".env" .gitignore
grep "NEXTAUTH_SECRET" .env.local  # Must NOT be in .env file

# Verify not in version control:
git log --all --source -- ".env" | head
git log --all --source -- ".env.local" | head
```

**2. DATABASE_URL**
- PostgreSQL connection string with credentials
- Never logged or exposed in error messages
- Connection pooling recommended (PgBouncer, Prisma connection pooling)

```bash
# Check for accidental exposure:
grep -r "DATABASE_URL" app/ --include="*.ts" --include="*.tsx" \
  | grep -v "process.env.DATABASE_URL"

# Should ONLY appear in:
# - lib/prisma.ts (via process.env)
# - .env.local (not committed)
# - Deployment environment variables

# Verify no connection strings in error logs:
grep -r "postgresql://\|postgres://\|@" app/ --include="*.ts" \
  | grep -v "process.env\|example\|SAMPLE"
```

**3. NEXTAUTH_URL**
- Must match deployment domain exactly
- Used for OAuth redirects and session validation
- Should include protocol (https://)

```bash
# Verify format in production:
echo $NEXTAUTH_URL
# Must be: https://yourdomain.com (no trailing slash)
```

### Public Variables (Can be in Code)

**1. NEXT_PUBLIC_APP_URL**
- Public base URL for API calls from client
- May differ from NEXTAUTH_URL for deployments

**2. NEXT_PUBLIC_VERCEL_URL**
- Auto-set by Vercel deployments
- Used for preview/staging deployments
- Safe to be public

**3. NEXT_PUBLIC_MAPBOX_TOKEN**
- **CRITICAL**: Mapbox API key is public (NEXT_PUBLIC prefix)
- Must be restricted on Mapbox dashboard to:
  - Specific domains (your domain only)
  - Specific endpoints (Maps, Geolocation only)
  - URL-based restrictions enabled
  - Refused for usage from unauthorized domains

```bash
# Verify in Mapbox dashboard:
# 1. Login to mapbox.com
# 2. Account > Tokens
# 3. Find NEXT_PUBLIC_MAPBOX_TOKEN
# 4. Verify:
#    - Scopes: maps:read (not maps:write)
#    - URL restrictions: Enabled to *.crewlink.com or similar
#    - No wildcard domains
```

**4. NEXT_PUBLIC_ENABLE_ROLE_TOGGLE**
- Development/QA flag for role switching
- **MUST be false in production**

```bash
# Verify production setting:
grep "NEXT_PUBLIC_ENABLE_ROLE_TOGGLE" .env.production*
# Must be: NEXT_PUBLIC_ENABLE_ROLE_TOGGLE=false
# Or completely absent (defaults to false)
```

### Environment Variable Audit Script
```bash
#!/bin/bash
# run-security-env-audit.sh

echo "=== Environment Variable Security Audit ==="

# 1. Check .gitignore for secrets
echo -e "\n[1] Checking .gitignore configuration..."
if grep -q "^\.env" .gitignore; then
  echo "✓ .env files are in .gitignore"
else
  echo "✗ ERROR: .env files not in .gitignore"
fi

# 2. Verify secrets not in Git history
echo -e "\n[2] Checking Git history for secrets..."
if git log --all --source -- "*.env*" 2>/dev/null | grep -q "."; then
  echo "✗ WARNING: .env files found in Git history"
  git log --all --source -- "*.env*" | head -5
else
  echo "✓ No .env files in Git history"
fi

# 3. Check for secret patterns in code
echo -e "\n[3] Checking for hardcoded secrets in source code..."
SECRET_PATTERNS=(
  "postgresql://.*:.*@"
  "DATABASE_URL.*=.*postgresql"
  "NEXTAUTH_SECRET.*=.*[a-z0-9]"
  "api_key.*=.*[a-z0-9]"
)

for pattern in "${SECRET_PATTERNS[@]}"; do
  if grep -r "$pattern" app/ lib/ --include="*.ts" --include="*.tsx" --exclude-dir=node_modules 2>/dev/null; then
    echo "✗ WARNING: Possible hardcoded secret matching: $pattern"
  fi
done
echo "✓ No obvious hardcoded secrets found"

# 4. Verify NEXTAUTH_SECRET length
echo -e "\n[4] Checking NEXTAUTH_SECRET length..."
if [ -z "$NEXTAUTH_SECRET" ]; then
  echo "⚠ NEXTAUTH_SECRET not set in current environment"
else
  SECRET_LEN=${#NEXTAUTH_SECRET}
  if [ $SECRET_LEN -lt 32 ]; then
    echo "✗ ERROR: NEXTAUTH_SECRET is too short ($SECRET_LEN chars, minimum 32)"
  else
    echo "✓ NEXTAUTH_SECRET length is adequate ($SECRET_LEN chars)"
  fi
fi

# 5. Check public env var restrictions
echo -e "\n[5] Checking NEXT_PUBLIC_* variable restrictions..."
if grep -r "DATABASE_URL\|NEXTAUTH_SECRET" --include="*.ts" --include="*.tsx" --include="*.js" app/ lib/ 2>/dev/null | grep -v "process.env" | grep -q "."; then
  echo "✗ WARNING: Possible exposure of secret variables"
else
  echo "✓ Secret variables not directly exposed"
fi

echo -e "\n=== Audit Complete ==="
```

---

## Password Security

### Password Requirements
Implement and enforce strong password policies:

```typescript
// Password validation function to implement:
const validatePassword = (password: string): { valid: boolean; errors: string[] } => {
  const errors = [];

  if (password.length < 12) errors.push('Password must be at least 12 characters');
  if (!/[A-Z]/.test(password)) errors.push('Password must contain uppercase letter');
  if (!/[a-z]/.test(password)) errors.push('Password must contain lowercase letter');
  if (!/[0-9]/.test(password)) errors.push('Password must contain digit');
  if (!/[!@#$%^&*()_+\-=\[\]{};:'",.<>?/\\|`~]/.test(password)) {
    errors.push('Password must contain special character');
  }

  return { valid: errors.length === 0, errors };
};
```

### Password Hashing
All passwords are hashed using **bcryptjs**:

```bash
# Verify bcryptjs is used in registration:
grep -r "bcryptjs\|bcrypt.hash\|bcrypt.compare" app/ lib/ --include="*.ts"

# Expected pattern:
# import bcrypt from 'bcryptjs'
# const hash = await bcrypt.hash(password, 12)
# const isValid = await bcrypt.compare(password, user.password)
```

**Critical Rules:**
1. **Never store plaintext passwords** - Always hash before DB insertion
2. **Never log passwords** - Exclude from error messages and logs
3. **Never transmit passwords** - Use HTTPS only
4. **Never compare passwords in SQL** - Use bcrypt.compare() in application
5. **Bcrypt salt rounds**: Use minimum 12 (default in NextAuth)

```bash
# Verify bcrypt salt rounds:
grep -r "bcrypt.hash" app/ lib/ --include="*.ts" -A 1 | grep -E "hash|12|10"
# Should show: bcrypt.hash(password, 12)
```

### Password Reset Flow
If password reset is implemented:

```bash
# Search for password reset routes:
grep -r "forgot-password\|reset-password\|password-reset" app/ --include="*.ts" --include="*.tsx"

# Verify:
# 1. Reset tokens are cryptographically random
# 2. Reset tokens expire after 1 hour
# 3. Reset tokens are single-use
# 4. Reset link uses HTTPS
# 5. Reset email is sent to account email address only (not user-supplied)
# 6. Rate limiting on password reset requests
```

### Account Lockout Protection
Implement rate limiting to prevent brute force attacks:

```typescript
// IMPLEMENT: Failed login attempt tracking
// - Lock account after 5 failed attempts for 15 minutes
// - Log failed attempts with IP address and timestamp
// - Clear attempts on successful login
// - Notify user of suspicious activity

// Example (pseudo-code):
const trackFailedLogin = async (email: string, ipAddress: string) => {
  const attempts = await getFailedAttempts(email);
  if (attempts >= 5) {
    await lockAccount(email, 15 * 60 * 1000); // 15 minutes
    await sendSecurityAlert(email, { ip: ipAddress, action: 'account_locked' });
  }
};
```

---

## Data Isolation & Privacy

### Worker Personal Data Protection
Worker profiles contain highly sensitive information that must NOT be exposed to hirers.

**Protected Worker Data:**
- Full address/detailed location (only city may be shown)
- Phone number (only shown after job acceptance)
- ID/verification documents (completely private)
- Background check results (private)
- Social Security Number or national ID (if stored)
- Bank account details (private)
- Email address (only to job poster after hire)

```bash
# Audit worker data exposure:

# 1. Check job listing query scope:
grep -r "findMany.*job" app/api --include="*.ts" -A 10 | grep -E "select|include|where"

# CORRECT: Limit worker data in listings
# select: {
#   id: true, title: true, location: { select: { city: true } },
#   worker: { select: { name: true, avatarUrl: true } }
# }

# WRONG: Includes full worker details
# include: { worker: true }

# 2. Check bid listing query scope:
grep -r "findMany.*bid" app/api --include="*.ts" -A 10

# CORRECT: Bids only visible to job poster and bidder
# where: {
#   job: { userId: session.user.id }
#   OR bidder: { id: session.user.id }
# }
```

### Hirer Payment Data Protection
Payment information must not be exposed to workers or leaked in responses.

**Protected Hirer Data:**
- Payment method details (never in API responses)
- Billing address
- Transaction history (worker only sees final amount earned)
- Credit card/bank account info

```bash
# Audit payment data queries:
grep -r "payment\|stripe\|transaction" app/api --include="*.ts" -A 5

# Verify payment details never returned to non-owner:
grep -r "PaymentMethod\|Card\|Billing" app/api --include="*.ts" \
  | grep -v "userId: session.user.id\|owner_id"
```

### Job Location Data
Location is semi-public but with restrictions:

```
Public: City, general area shown on map listings
Restricted: Exact street address only shown to:
  - Job poster (hirer)
  - Worker who accepted the job
Hidden: Precise GPS coordinates (used for map zoom, not shown)
```

```bash
# Audit job location queries:
grep -r "location\|address\|coordinates\|lat\|lng" app/api --include="*.ts"

# Verify location scoping:
# - Listings: Only city in results
# - Job detail (unauthorized worker): No address
# - Job detail (hired worker): Full address
# - Worker location: Never expose to other workers
```

### Bid Amount Visibility
Bids are confidential to job poster and bidder:

```typescript
// CORRECT: Only visible to poster and bidder
const bids = await prisma.bid.findMany({
  where: {
    jobId: jobId,
    OR: [
      { job: { userId: session.user.id } },        // Poster sees all
      { bidderId: session.user.id }                // Bidder sees own
    ]
  }
});

// WRONG: Returns all bids without authorization check
const bids = await prisma.bid.findMany({ where: { jobId } });
```

### Message Privacy
Messages are only accessible to conversation participants:

```bash
# Audit message query authorization:
grep -r "conversation\|message" app/api --include="*.ts" -A 5

# VERIFY: Must check user is participant
# const conversation = await prisma.conversation.findUnique({
#   where: { id: conversationId },
#   include: { participants: true }
# });
#
# const isParticipant = conversation.participants.some(p => p.id === session.user.id);
# if (!isParticipant) return 403;
```

---

## API Route Authorization

### Authorization Middleware Pattern
All API routes must implement consistent authorization:

```typescript
// STANDARD PATTERN for protected API routes:
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);

  // 1. Authentication check
  if (!session?.user) {
    return new NextResponse(JSON.stringify({ error: "Unauthorized" }), {
      status: 401,
      headers: { "content-type": "application/json" }
    });
  }

  // 2. Authorization check (role-based)
  if (session.user.role !== 'hirer') {
    return new NextResponse(JSON.stringify({ error: "Forbidden" }), {
      status: 403,
      headers: { "content-type": "application/json" }
    });
  }

  // 3. Resource ownership check (if applicable)
  const jobId = request.nextUrl.searchParams.get('jobId');
  const job = await prisma.job.findUnique({ where: { id: jobId } });

  if (job.userId !== session.user.id) {
    return new NextResponse(JSON.stringify({ error: "Forbidden" }), {
      status: 403,
      headers: { "content-type": "application/json" }
    });
  }

  // 4. Safe to proceed with operation
  // ... handle request
}
```

### Job Management Routes

**POST /api/jobs**
- **Authentication:** Required
- **Authorization:** User must be 'hirer' role
- **Validation:** Job title, description, budget, location required
- **Data Isolation:** User can only create jobs for themselves (userId = session.user.id)

```bash
# Audit implementation:
grep -r "POST.*jobs" app/api --include="*.ts" -B 2 -A 10

# Verify all conditions:
grep -E "role.*hirer|role !== 'hirer'" app/api/jobs/route.ts
grep -E "userId.*session.user.id" app/api/jobs/route.ts
```

**GET /api/jobs**
- **Authentication:** Optional (public job listings)
- **Authorization:** Not applicable (all authenticated users see public listings)
- **Data Filtering:** Must not expose restricted fields (full addresses, worker details)
- **Pagination:** Implement to prevent DoS (default limit 20, max 100)

```typescript
// CORRECT: Safe public listing
const jobs = await prisma.job.findMany({
  skip: (page - 1) * limit,
  take: Math.min(limit, 100),
  select: {
    id: true,
    title: true,
    description: true,
    budget: true,
    location: { select: { city: true, state: true } }, // NOT street address
    createdAt: true,
    hirer: { select: { name: true, avatarUrl: true } } // NOT contact info
  },
  orderBy: { createdAt: 'desc' }
});
```

**GET /api/jobs/[id]**
- **Authentication:** Optional for public fields, required for full details
- **Authorization:** Location details only to poster or accepted worker
- **Data Filtering:** Full address only visible to authorized users

```typescript
// CORRECT: Conditional data exposure based on authorization
const job = await prisma.job.findUnique({
  where: { id: jobId },
  include: {
    location: true,
    hirer: { select: { name: true, avatarUrl: true } },
    acceptedWorker: authorization includes job poster or accepted worker
  }
});

// Remove sensitive fields if not authorized
if (session?.user.id !== job.userId && session?.user.id !== job.acceptedWorkerId) {
  delete job.location.street;
  delete job.location.address; // Show only city
}
```

**PATCH /api/jobs/[id]**
- **Authentication:** Required
- **Authorization:** Only job poster (user who created it)
- **Ownership Check:** `job.userId === session.user.id`
- **Allowed Updates:** Only title, description, budget, status (NOT location once posted)

```bash
grep -r "PATCH.*jobs" app/api --include="*.ts" -A 15 | \
  grep -E "userId.*session.user.id|job.*owner|forbidden|403"
```

**DELETE /api/jobs/[id]**
- **Authentication:** Required
- **Authorization:** Only job poster
- **Soft delete recommended:** Mark as deleted rather than remove (audit trail)
- **Cascading:** Handle related bids/offers appropriately

```typescript
// PREFERRED: Soft delete maintains referential integrity
const job = await prisma.job.update({
  where: { id: jobId },
  data: {
    deletedAt: new Date(),
    status: 'cancelled'
  }
});

// NOT: Hard delete
await prisma.job.delete({ where: { id: jobId } }); // Loses audit trail
```

### Bid Management Routes

**POST /api/bids**
- **Authentication:** Required
- **Authorization:** User must be 'worker' role
- **Validation:** Amount > 0, job exists, job not already accepted, worker not already bidding on job
- **Rate Limiting:** Prevent bid spam (e.g., max 10 bids per hour)

```typescript
const newBid = await prisma.bid.create({
  data: {
    jobId: jobId,
    bidderId: session.user.id,  // CRITICAL: Use session user, not request body
    amount: parseInt(body.amount),
    proposal: body.proposal
  }
});
```

**GET /api/bids**
- **Authentication:** Required
- **Authorization:** Only see:
  - All bids on jobs you posted (hirer)
  - Your own bids (worker)

```typescript
// CORRECT: Role-based visibility
const bids = await prisma.bid.findMany({
  where: {
    OR: [
      { job: { userId: session.user.id } },    // All bids on my jobs
      { bidderId: session.user.id }            // My bids
    ]
  }
});
```

**PATCH /api/bids/[id]** (Accept/Reject)
- **Authentication:** Required
- **Authorization:** Only job poster can accept/reject
- **Validation:** Bid exists, job is still open, no other bid already accepted
- **Atomic Operations:** Accepting one bid should auto-reject others (transaction)

```typescript
// CORRECT: Atomic transaction
const result = await prisma.$transaction([
  prisma.bid.update({
    where: { id: acceptBidId },
    data: { status: 'accepted' }
  }),
  prisma.bid.updateMany({
    where: { jobId: job.id, id: { not: acceptBidId } },
    data: { status: 'rejected' }
  }),
  prisma.job.update({
    where: { id: jobId },
    data: { acceptedWorkerId: bid.bidderId, status: 'accepted' }
  })
]);
```

### Conversation & Message Routes

**GET /api/conversations**
- **Authentication:** Required
- **Authorization:** Only user's own conversations

```typescript
const conversations = await prisma.conversation.findMany({
  where: {
    participants: {
      some: { id: session.user.id }
    }
  }
});
```

**POST /api/conversations/[id]/messages**
- **Authentication:** Required
- **Authorization:** User must be conversation participant
- **Validation:** Message content not empty, max length enforced
- **Rate Limiting:** Prevent message spam

### Profile Routes

**GET /api/profile/[userId]**
- **Authentication:** Optional
- **Authorization:** Public fields only (name, avatar, role, skills)
- **Data Filtering:** Personal contact info never in response

```typescript
// CORRECT: Limited public profile
const profile = await prisma.user.findUnique({
  where: { id: userId },
  select: {
    id: true,
    name: true,
    avatarUrl: true,
    role: true,
    skills: true,  // If worker
    rating: true,
    reviewCount: true,
    // NOT: email, phone, address, id documents
  }
});
```

**PATCH /api/profile**
- **Authentication:** Required
- **Authorization:** Only own profile
- **Validation:** Email uniqueness, phone format, avatar URL validation
- **Restriction:** Cannot change role (requires admin intervention)

```typescript
// CORRECT: Prevent role change
const updatedUser = await prisma.user.update({
  where: { id: session.user.id },
  data: {
    name: body.name,
    phone: body.phone,
    avatarUrl: body.avatarUrl,
    // NOT including: role, email (or email change requires verification)
  }
});
```

---

## Prisma Query Security

### Critical Rule: User Scoping in Every Query

**RULE: Every database query must include a where clause that scopes to the authenticated user.**

This prevents information disclosure and unauthorized data access.

```typescript
// ❌ WRONG - Returns ALL jobs
const jobs = await prisma.job.findMany();

// ✓ CORRECT - Returns only user's jobs
const jobs = await prisma.job.findMany({
  where: { userId: session.user.id }
});

// ❌ WRONG - Returns user's jobs but includes all bids
const jobsWithBids = await prisma.job.findMany({
  where: { userId: session.user.id },
  include: { bids: true }  // Exposes all bids (including from other workers)
});

// ✓ CORRECT - Selective bid inclusion
const jobsWithBids = await prisma.job.findMany({
  where: { userId: session.user.id },
  include: {
    bids: {
      select: { id: true, amount: true, status: true }  // Only safe fields
    }
  }
});
```

### Audit Prisma Queries for User Scoping

```bash
#!/bin/bash
# audit-prisma-scoping.sh

echo "=== Prisma Query Security Audit ==="

# Find all Prisma queries
echo -e "\n[1] Searching for Prisma queries..."
QUERY_FILES=$(grep -r "prisma\." app/ lib/ --include="*.ts" --include="*.tsx" \
  | grep -E "findMany|findUnique|findFirst|create|update|delete" \
  | cut -d: -f1 | sort -u)

echo "Found Prisma queries in:"
echo "$QUERY_FILES"

# Check for queries WITHOUT where clause in protected resources
echo -e "\n[2] Checking for unscoped queries in protected resources..."
for file in $QUERY_FILES; do
  if [[ "$file" == *"/api/"* ]]; then
    if grep -q "prisma\.job\.findMany\(\)" "$file"; then
      echo "✗ ISSUE: findMany() without where clause in $file"
    fi
    if grep -q "prisma\.bid\.findMany\(\)" "$file"; then
      echo "✗ ISSUE: bid query without where clause in $file"
    fi
    if grep -q "prisma\.user\.findMany\(\)" "$file"; then
      echo "✗ ISSUE: user query without where clause in $file"
    fi
  fi
done

# Check for include/select with potentially sensitive relations
echo -e "\n[3] Checking for over-inclusive select statements..."
grep -r "include.*{" app/api --include="*.ts" | \
  grep -E "include.*user|include.*password|include.*bids|include.*addresses" | \
  while read line; do
    echo "⚠ Review: $line"
  done

echo -e "\n=== Audit Complete ==="
```

### SQL Injection Prevention
Prisma uses parameterized queries, preventing SQL injection by default:

```typescript
// ✓ SAFE - Parameterized query
const user = await prisma.user.findUnique({
  where: { email: userInput }  // Safely parameterized
});

// ❌ DANGEROUS - String concatenation (doesn't exist in Prisma, but shown for context)
// const user = await prisma.$queryRaw`SELECT * FROM User WHERE email = '${userInput}'`
// Never use raw queries with string concatenation
```

**Safe Practices:**
- Always use Prisma client methods (findMany, create, update, delete)
- Use `where` clauses with typed filters
- Avoid `prisma.$queryRaw()` unless absolutely necessary
- If using `$queryRaw()`, use tagged template literals with parameter binding:

```typescript
// ✓ SAFE - Even with raw SQL
const user = await prisma.$queryRaw`
  SELECT * FROM "User" WHERE "email" = ${userInput}
`;

// ❌ DANGEROUS - String concatenation
const user = await prisma.$queryRaw(`
  SELECT * FROM "User" WHERE "email" = '${userInput}'
`);
```

### Common Vulnerable Patterns

**Pattern 1: Missing Authorization Check**
```typescript
// ❌ WRONG
const job = await prisma.job.findUnique({ where: { id: jobId } });
await prisma.job.update({
  where: { id: jobId },
  data: { title: newTitle }
});

// ✓ CORRECT
const job = await prisma.job.findUnique({ where: { id: jobId } });
if (job.userId !== session.user.id) throw new Error('Forbidden');
await prisma.job.update({
  where: { id: jobId },
  data: { title: newTitle }
});
```

**Pattern 2: Over-inclusive Relations**
```typescript
// ❌ WRONG - Includes full user objects with sensitive data
const jobs = await prisma.job.findMany({
  include: { hirer: true, acceptedWorker: true }
});

// ✓ CORRECT - Select only safe fields
const jobs = await prisma.job.findMany({
  select: {
    id: true,
    title: true,
    hirer: { select: { name: true, avatarUrl: true } },
    acceptedWorker: { select: { name: true, avatarUrl: true } }
  }
});
```

**Pattern 3: Unfiltered List Queries**
```typescript
// ❌ WRONG - Returns ALL data
const workers = await prisma.user.findMany({
  where: { role: 'worker' }
});

// ✓ CORRECT - Paginated with safe fields
const workers = await prisma.user.findMany({
  where: { role: 'worker' },
  select: { id: true, name: true, avatarUrl: true },
  skip: (page - 1) * 20,
  take: 20,
  orderBy: { rating: 'desc' }
});
```

### Audit Script for Sensitive Field Exposure

```bash
# Find queries that might expose sensitive fields:
grep -r "include: {" app/api --include="*.ts" | \
  grep -E "password|phone|address|ssn|bank|credit" && \
  echo "✗ Possible sensitive field exposure"

grep -r "findMany.*true" app/api --include="*.ts" | \
  grep -E "job|bid|user|profile" && \
  echo "⚠ Review for over-inclusive queries"
```

---

## JWT Configuration Review

### JWT Structure in CrewLink
The JWT payload contains the user session:

```typescript
// Standard JWT payload (from NextAuth)
{
  sub: "user-id",           // Subject (user ID)
  name: "John Doe",         // User display name
  email: "john@example.com",
  image: "https://...",     // Avatar URL
  role: "hirer",            // CrewLink role
  iat: 1234567890,          // Issued at
  exp: 1234571490,          // Expires
  jti: "unique-token-id"    // JWT ID
}
```

### Critical JWT Checks

**1. Verify Signing Algorithm**
```bash
# In lib/auth.ts, verify:
grep -A 20 "jwt:" lib/auth.ts | grep -E "algorithm|encode|decode"

# Should show: algorithm: 'HS256' or 'RS256'
# NEVER: algorithm: 'none'
```

**2. Verify Secret Strength**
```typescript
// WRONG: Weak or short secrets
secret: 'mysecret'                    // Too short
secret: 'abc123'                      // Predictable

// CORRECT: Strong random secret
secret: process.env.NEXTAUTH_SECRET   // Must be 32+ chars, random
```

**3. Session Token Expiration**
```bash
# Verify in lib/auth.ts:
grep -E "maxAge|expires|session" lib/auth.ts

# Expected values:
# maxAge: 30 * 24 * 60 * 60  // 30 days
# Or configured per-deployment requirements
```

**4. JWT Should Not Contain Secrets**
```typescript
// ❌ WRONG: Hashed password in JWT
const token = { user: { id, email, password: user.password } };

// ✓ CORRECT: Only safe data in JWT
const token = { user: { id, email, name, role, image } };
// Password never included, only accessed from DB when needed
```

### JWT Validation in API Routes

```typescript
// STANDARD: Get and validate session (JWT from cookie)
import { getServerSession } from 'next-auth/next';

const session = await getServerSession(authOptions);
if (!session?.user?.id) {
  return new NextResponse(null, { status: 401 });
}

// Session object contains validated JWT payload
// Do NOT parse JWT manually, use getServerSession()
```

### Token Refresh Flow
NextAuth automatically refreshes tokens:

```bash
# Verify refresh mechanism:
grep -r "refresh\|rotate" lib/auth.ts app/api

# Should show automatic token refresh on each request
# No manual refresh token handling needed (handled by NextAuth)
```

---

## Sensitive Data Handling

### Worker Verification Documents
Worker ID documents and background checks are HIGHLY SENSITIVE:

```prisma
model WorkerVerification {
  id           String    @id @default(cuid())
  workerId     String
  worker       User      @relation(fields: [workerId], references: [id])
  documentType String    // 'government_id' | 'drivers_license'
  fileUrl      String    // URL to secure storage (S3, etc.)
  uploadedAt   DateTime  @default(now())
  verifiedAt   DateTime?
  verifiedBy   String?   // Admin user ID
  status       String    // 'pending' | 'verified' | 'rejected'
  expiresAt    DateTime?
}
```

**Access Rules:**
- Only the worker themselves can view their own documents
- Only admins/verification team can access documents
- Never exposed in API responses to other users
- Never downloaded to local storage without encryption

```typescript
// CORRECT: Restricted document access
const documents = await prisma.workerVerification.findMany({
  where: {
    workerId: session.user.id  // Only own documents
  }
});

// WRONG: Admin viewing without authorization check
const documents = await prisma.workerVerification.findMany();
```

### Payment Method Storage
Payment methods should NEVER be stored in the CrewLink database:

**Best Practice:**
- Use Stripe, PayPal, or Braintree for payment processing
- Store only payment processor's token ID (not card details)
- Never log or cache full payment method info

```typescript
// CORRECT: Store processor token only
const payment = {
  stripeCustomerId: 'cus_...',
  stripeTokenId: 'tok_...',  // Token ID, not card number
  last4: '4242'              // Safe to display (no PII)
};

// WRONG: Storing card details
const payment = {
  cardNumber: '4242 4242 4242 4242',    // NEVER
  expiryDate: '12/25',                  // NEVER
  cvv: '123'                            // NEVER
};
```

### Geolocation Data
Location data must be handled carefully:

```typescript
// PUBLIC: City-level location in listings
export interface JobListing {
  city: string;
  state: string;
  country: string;
}

// RESTRICTED: Street address (only to authorized users)
export interface JobDetails {
  streetAddress: string;
  city: string;
  state: string;
  postalCode: string;
  // Exact GPS coordinates: Never expose directly
}

// PRIVATE: User home location
export interface WorkerProfile {
  homeAddress: string;      // Never shown in listings
  serviceArea: string[];    // Cities worker covers
}
```

```bash
# Audit location data exposure:
grep -r "location\|address\|gps\|coordinates" app/api --include="*.ts" -B 2 -A 2 | \
  grep -E "select|include" | \
  grep -v "city\|state"

# Should NOT return street addresses to unauthorized users
```

### Email Address Exposure
Email addresses should not be exposed to other users:

```typescript
// PUBLIC: Email of job poster (after worker accepts job)
// PRIVATE: Worker email (shown to hirer only after hire)
// PRIVATE: User email in listings/searches

// CORRECT: Conditional email exposure
if (session.user.id === job.userId || session.user.id === job.acceptedWorkerId) {
  userObject.email = user.email;  // Safe to expose after hire
} else {
  delete userObject.email;  // Never expose to unauthorized users
}
```

### Phone Number Security
Phone numbers are sensitive PII:

```typescript
// PUBLIC: Only after job acceptance
// PRIVATE: In all listings and searches

// CORRECT: Masked phone number before hire
const workerInfo = {
  name: worker.name,
  phone: worker.phone ? worker.phone.substring(0, 3) + '-****-****' : null,
  // Only show full phone to job poster AFTER hire
};
```

---

## Development/Production Checks

### Mock User for Development
CrewLink uses a mock user in development for testing:

```bash
# Verify mock user configuration:
grep -r "MOCK_USER\|mock.*user\|dev.*user" store/ --include="*.ts"

# Should be in: store/index.ts or similar auth store

# CRITICAL: Mock user must NOT reach production
grep -r "MOCK_USER" --include="*.env*" --include="*.ts"
# Should only appear in TypeScript files for conditional logic:
if (process.env.NODE_ENV === 'development') {
  // Use mock user
}
```

**Audit Script:**
```bash
# Verify mock user safety:
echo "=== Mock User Security Check ==="

# 1. Check mock user only in development
if grep -r "MOCK_USER\|mockUser" --include="*.ts" | grep -v "NODE_ENV === 'development'" | grep -q "."; then
  echo "✗ ERROR: Mock user found outside development check"
else
  echo "✓ Mock user properly guarded by NODE_ENV check"
fi

# 2. Verify mock user not in production build
if [ -d "build" ] || [ -d "dist" ] || [ -d ".next" ]; then
  if grep -r "mockUser\|MOCK_USER" build/ dist/ .next/ 2>/dev/null | grep -q "."; then
    echo "✗ ERROR: Mock user found in production build"
  else
    echo "✓ Mock user not in production build"
  fi
fi

# 3. Check mock user not in environment variables
if grep -r "MOCK_USER" .env.production .env.production.local 2>/dev/null; then
  echo "✗ ERROR: MOCK_USER in production environment"
else
  echo "✓ No MOCK_USER in production environment"
fi
```

### Role Toggle Feature Flag
Development feature for testing both roles:

```bash
# Verify ENABLE_ROLE_TOGGLE is production-safe:
grep -r "NEXT_PUBLIC_ENABLE_ROLE_TOGGLE" --include="*.env*" --include="*.ts"

# In production:
# .env.production should have: NEXT_PUBLIC_ENABLE_ROLE_TOGGLE=false
# OR the variable should not exist at all

# Verify implementation:
grep -r "ENABLE_ROLE_TOGGLE" --include="*.tsx" --include="*.ts" -B 2 -A 2 | \
  grep -E "if.*ENABLE_ROLE_TOGGLE|process.env.NEXT_PUBLIC"

# Should show conditional role switching only when flag is true
```

### Environment-Specific Configuration

**Development (.env.local):**
```env
DATABASE_URL=postgresql://dev:dev@localhost:5432/crewlink_dev
NEXTAUTH_URL=http://localhost:3000
NEXTAUTH_SECRET=dev-secret-minimum-32-characters-long!
NEXT_PUBLIC_ENABLE_ROLE_TOGGLE=true
MOCK_USER_ENABLED=true
NODE_ENV=development
```

**Staging (.env.staging):**
```env
DATABASE_URL=postgresql://[user]:[pass]@staging-db.internal/crewlink_staging
NEXTAUTH_URL=https://staging.crewlink.com
NEXTAUTH_SECRET=[strong random 32+ chars]
NEXT_PUBLIC_ENABLE_ROLE_TOGGLE=false
NODE_ENV=production
```

**Production (.env.production):**
```env
DATABASE_URL=postgresql://[prod-user]:[prod-pass]@prod-db.internal/crewlink
NEXTAUTH_URL=https://crewlink.com
NEXTAUTH_SECRET=[strong random 32+ chars, minimum 64]
NEXT_PUBLIC_ENABLE_ROLE_TOGGLE=false
NODE_ENV=production
```

### Build-Time Security Checks
Implement checks in build process:

```typescript
// next.config.js - Add security validation
const nextConfig = {
  onDemandEntries: {
    maxInactiveAge: 15000,
    pagesBufferLength: 5,
  },
  // Validate environment at build time
  webpack: (config, { isServer }) => {
    if (isServer && process.env.NODE_ENV === 'production') {
      // Validate critical security variables
      const required = ['NEXTAUTH_SECRET', 'DATABASE_URL', 'NEXTAUTH_URL'];
      const missing = required.filter(v => !process.env[v]);

      if (missing.length > 0) {
        throw new Error(`Missing required env vars: ${missing.join(', ')}`);
      }

      // Verify flag is disabled
      if (process.env.NEXT_PUBLIC_ENABLE_ROLE_TOGGLE === 'true') {
        throw new Error('NEXT_PUBLIC_ENABLE_ROLE_TOGGLE must be false in production');
      }
    }
    return config;
  },
};
```

---

## OWASP Top 10 CrewLink-Specific Checks

### A01: Broken Access Control
**Risk in CrewLink:** Workers access hirers' job details or payments; hirers see worker addresses before hire.

**Audit:**
```bash
# 1. Check all routes restrict access by role and ownership
grep -r "router\.\|app\/api" app/ --include="*.ts" | grep -E "POST|PATCH|DELETE" | \
  while read route; do
    if ! grep -l "session\|auth\|role\|owner" "$route"; then
      echo "⚠ Unprotected route: $route"
    fi
  done

# 2. Verify data filtering in responses
grep -r "hirer\|worker\|address\|phone\|payment" app/api --include="*.ts" | \
  grep -v "select\|where.*userId\|where.*bidderId" && \
  echo "⚠ Possible data exposure"
```

**Fix:**
- Implement authorization check on every API route
- Always verify `session.user.id` matches resource owner
- Use Prisma `where` clause to scope queries to user

### A02: Cryptographic Failures
**Risk in CrewLink:** DATABASE_URL exposed, NEXTAUTH_SECRET weak, passwords stored plaintext.

**Audit:**
```bash
# 1. Verify strong secret
echo "NEXTAUTH_SECRET length: ${#NEXTAUTH_SECRET}"
# Must be > 32

# 2. Check password hashing
grep -r "bcrypt.hash\|bcryptjs" lib/auth.ts app/api --include="*.ts"
# Must use bcryptjs with salt 12

# 3. Verify HTTPS in production
grep -r "NEXTAUTH_URL\|http://" .env.production* 2>/dev/null
# Must be https://, never http://
```

**Fix:**
- Use minimum 32-character random NEXTAUTH_SECRET
- Always hash passwords with bcryptjs (12 rounds)
- Enforce HTTPS everywhere in production

### A03: Injection
**Risk in CrewLink:** SQL injection in queries, NoSQL injection if using MongoDB, message XSS.

**Audit:**
```bash
# 1. Check for raw SQL
grep -r "\$queryRaw\|query(\|sql\`" app/ lib/ --include="*.ts"
# If found, verify parameterized queries only

# 2. Check for XSS in message handling
grep -r "dangerouslySetInnerHTML\|innerHTML" app/ --include="*.tsx"
# Should NOT display user-generated content without sanitization

# 3. Validate input handling
grep -r "request.body\|request.json()" app/api --include="*.ts" -A 2 | \
  grep -v "validate\|schema\|zod\|yup"
# All inputs must be validated
```

**Fix:**
- Use Prisma parameterized queries only
- Sanitize HTML content (use DOMPurify or similar)
- Validate all inputs with Zod, Yup, or similar

### A04: Insecure Design
**Risk in CrewLink:** No rate limiting, missing verification, no audit logs.

**Implement:**
```typescript
// Add rate limiting middleware
import rateLimit from 'express-rate-limit';

const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5,                     // 5 attempts
  message: 'Too many login attempts, try again later'
});

app.post('/api/auth/signin', loginLimiter, (req, res) => {
  // Handle login
});

// Add audit logging
const auditLog = async (action, userId, details) => {
  await prisma.auditLog.create({
    data: {
      action,
      userId,
      details,
      ipAddress: req.ip,
      timestamp: new Date()
    }
  });
};
```

**Fix:**
- Implement rate limiting on login (5 attempts per 15 min)
- Add audit logging for sensitive actions
- Implement account lockout after failed attempts
- Require email verification for new accounts

### A05: Broken Authentication
**Risk in CrewLink:** Weak password requirements, no MFA, session fixation.

**Audit:**
```bash
# 1. Check password requirements
grep -r "validatePassword\|password.*length\|password.*regex" app/api --include="*.ts"

# 2. Verify session token handling
grep -r "sessionToken\|session.*secure\|httpOnly" lib/auth.ts

# 3. Check for session fixation protection
grep -r "regenerate\|invalidate.*session" --include="*.ts"
```

**Fix:**
- Enforce minimum 12-character passwords with complexity
- Implement session token expiration and refresh
- Add IP address validation in sessions
- Implement optional MFA (TOTP) for sensitive accounts

### A06: Sensitive Data Exposure
**Risk in CrewLink:** Worker addresses in job listings, payment info in logs, tokens in URLs.

**Audit:**
```bash
# 1. Check for sensitive data in logs
grep -r "console.log\|logger" app/ --include="*.ts" | \
  grep -E "password|token|secret|address|phone|email|payment"

# 2. Check for data in URLs
grep -r "?.*=.*\[a-zA-Z0-9\]" app/ --include="*.ts" | \
  grep -E "password|token|address|id.*document"

# 3. Verify API responses don't expose sensitive fields
grep -r "JSON.stringify.*password\|JSON.stringify.*token" app/api --include="*.ts"
```

**Fix:**
- Never log sensitive data (use data.hashedValue instead)
- Never pass sensitive data in URL parameters
- Filter API responses to only safe fields
- Implement PII masking in logs

### A07: Cross-Site Scripting (XSS)
**Risk in CrewLink:** Job descriptions with HTML, user messages with injected scripts.

**Audit:**
```bash
# 1. Find potentially unsafe HTML rendering
grep -r "dangerouslySetInnerHTML\|innerHTML" app/ --include="*.tsx"

# 2. Check for user input in HTML attributes
grep -r "style=\|onClick=\|on[A-Z]" app/ --include="*.tsx" | \
  grep -v "const\|{.*}\|function"

# 3. Verify HTML escaping
grep -r "<div>\|<p>\|<span>" app/ --include="*.tsx" | \
  grep -v "{.*}" | head -5
# Should see {variable} or similar, not direct HTML
```

**Fix:**
```typescript
// CORRECT: React auto-escapes
const job = { description: "<script>alert('xss')</script>" };
<div>{job.description}</div>  // Renders as text, not executed

// WRONG: Bypasses escaping
<div dangerouslySetInnerHTML={{ __html: job.description }} />

// FIX: Use DOMPurify
import DOMPurify from 'dompurify';
<div>{DOMPurify.sanitize(job.description)}</div>
```

### A08: Software & Data Integrity Failures
**Risk in CrewLink:** Compromised dependencies, unverified updates, insecure CI/CD.

**Audit:**
```bash
# 1. Check dependencies for known vulnerabilities
npm audit
npm audit --audit-level=moderate  # Fail on moderate+ issues

# 2. Verify dependency integrity
npm ci  # Use package-lock.json, not npm install

# 3. Check for outdated packages
npm outdated

# 4. Verify no suspicious dependencies
npm list
# Look for unknown or unused packages
```

**Fix:**
- Run `npm audit fix` regularly
- Use `npm ci` in CI/CD pipelines
- Implement SBOM (Software Bill of Materials)
- Pin dependency versions exactly

### A09: Logging & Monitoring Failures
**Risk in CrewLink:** No error logs, no security event tracking, missed attacks.

**Implement:**
```typescript
// Add comprehensive logging
import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  defaultMeta: { service: 'crewlink-api' },
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});

// Log security events
logger.info('User login', { userId, email, ipAddress });
logger.warn('Failed login attempt', { email, ipAddress, attempts: 3 });
logger.error('Unauthorized access attempt', { userId, resource, ipAddress });
```

**Fix:**
- Log all authentication events
- Log all access to sensitive resources
- Monitor for repeated failed attempts
- Set up alerts for security events

### A10: Server-Side Request Forgery (SSRF)
**Risk in CrewLink:** Mapbox token misuse, webhook endpoints, image proxying.

**Audit:**
```bash
# 1. Verify Mapbox token restrictions
grep -r "MAPBOX\|mapbox\|geolocation" app/ --include="*.ts" --include="*.tsx"

# 2. Check for webhook implementations
grep -r "webhook\|callback\|notify" app/api --include="*.ts" | \
  grep -v "session\|auth"

# 3. Verify no image proxying
grep -r "image\|proxy\|fetch.*url" app/api --include="*.ts" | \
  head -10
```

**Fix:**
- Restrict Mapbox token to your domains only
- Validate webhook URLs are approved hosts
- Implement URL whitelist for any external requests
- Use signature verification for webhooks

---

## Third-Party Integration Security

### Mapbox GL Token Security
The Mapbox token is exposed as a public variable (NEXT_PUBLIC_MAPBOX_TOKEN).

**Restrict on Mapbox Dashboard:**

1. Login to mapbox.com → Account → Tokens
2. Find the NEXT_PUBLIC_MAPBOX_TOKEN
3. Edit token to set:
   - **Scopes:** Maps (only, not Geocoding or Directions)
   - **URL restrictions:** Enable
     - Add: `*.crewlink.com` (all subdomains)
     - Add: `https://crewlink.com` (main domain)
   - **No:** Wildcard domains or overly broad patterns

```bash
# Verify URL restrictions are set:
curl -H "Authorization: Bearer $MAPBOX_SECRET_KEY" \
  https://api.mapbox.com/tokens/[TOKEN_ID]

# Should show urlRoot set to crewlink domain
```

### Payment Processor Integration (Stripe/PayPal)
If integrated, sensitive handling required:

```typescript
// CORRECT: Process payments server-side only
// app/api/payments/process-payment.ts

export async function POST(request: Request) {
  const session = await getServerSession();
  if (!session?.user) return new NextResponse(null, { status: 401 });

  const body = await request.json();
  const { jobId, workerId } = body;

  // Never accept card details in request
  // Use Stripe/PayPal token only
  const paymentToken = body.stripeToken;  // From Stripe.js

  // Process server-side with secret key
  const charge = await stripe.charges.create({
    amount: jobAmount,
    currency: 'usd',
    source: paymentToken,
    metadata: { jobId, hirerId: session.user.id }
  });

  // Never return full payment details
  return NextResponse.json({
    success: true,
    transactionId: charge.id,
    // NOT: amount, card details, stripe response
  });
}

// WRONG: Client-side payment processing
// ❌ Stripe token in request body
// ❌ Server-side processing with publishable key
// ❌ Storing card details in database
```

### OAuth/SSO Integration (if implemented)
If adding Google/GitHub login:

```typescript
// CORRECT: OAuth with security headers
import { GoogleProvider } from 'next-auth/providers/google';

export const authOptions = {
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET,
      // Verify these are secure and not exposed
      allowDangerousEmailAccountLinking: false  // Prevent account takeover
    })
  ],
  // Callback to map provider user to CrewLink user
  callbacks: {
    async signIn({ user, account, profile, email, credentials }) {
      // Verify email domain if restricting
      // Set role based on email pattern if needed
      return true;
    }
  }
};
```

---

## Incident Response & Logging

### Security Event Logging
Implement comprehensive event logging:

```typescript
// Create audit trail for sensitive actions
const auditLog = async (
  event: 'LOGIN' | 'LOGOUT' | 'PAYMENT' | 'BID_ACCEPTED' | 'DATA_ACCESS',
  userId: string,
  details: Record<string, any>,
  ipAddress: string
) => {
  await prisma.auditLog.create({
    data: {
      event,
      userId,
      details: JSON.stringify(details),
      ipAddress,
      userAgent: navigator.userAgent,
      timestamp: new Date()
    }
  });
};

// Usage in API routes
auditLog('LOGIN', session.user.id, { method: 'email/password' }, req.ip);
auditLog('PAYMENT', userId, { jobId, amount: 5000 }, req.ip);
auditLog('BID_ACCEPTED', hirerId, { bidId, workerId }, req.ip);
```

### Monitoring & Alerting
Set up alerts for suspicious activity:

```typescript
// Monitor failed login attempts
const monitorFailedLogins = async (email: string, ipAddress: string) => {
  const failedAttempts = await prisma.failedLogin.count({
    where: {
      email,
      createdAt: { gte: new Date(Date.now() - 15 * 60 * 1000) }  // Last 15 min
    }
  });

  if (failedAttempts >= 5) {
    // Lock account and alert user
    await lockAccount(email);
    await sendSecurityAlert(email, {
      subject: 'Suspicious login attempts detected',
      body: `Multiple failed logins from ${ipAddress}`
    });
  }
};

// Monitor unusual payment amounts
const monitorPayment = async (amount: number, previousAverage: number) => {
  if (amount > previousAverage * 3) {
    // Alert for review
    await alertModerators({
      type: 'UNUSUAL_PAYMENT',
      amount,
      previousAverage,
      requiresReview: true
    });
  }
};
```

### Incident Response Plan
Document procedures for security incidents:

```markdown
## Incident Response Playbook

### Data Breach (credentials exposed)
1. Immediately invalidate all active sessions
2. Force password reset for affected users
3. Send security alerts with instructions
4. Rotate NEXTAUTH_SECRET
5. Audit log access
6. Report to affected users within 24 hours

### Compromised API Token
1. Rotate MAPBOX_TOKEN immediately
2. Update domain restrictions
3. Review audit logs for unauthorized usage
4. Implement rate limiting if abuse detected

### Unauthorized Access
1. Lock account immediately
2. Invalidate all sessions
3. Require re-authentication with email verification
4. Review access logs to determine exposure
5. Notify user of access attempt

### Payment Fraud
1. Invalidate affected payment methods
2. Freeze funds if possible
3. Contact payment processor (Stripe, PayPal)
4. Investigate transaction details
5. Notify affected users
6. Report to authorities if required
```

---

## Security Checklist

### Pre-Deployment Checklist
- [ ] NEXTAUTH_SECRET is 32+ characters and random
- [ ] NEXTAUTH_URL is https:// (production)
- [ ] DATABASE_URL uses secure connection
- [ ] All API routes validate session and authorization
- [ ] Sensitive routes check user.role
- [ ] Prisma queries scope with userId/bidderId where clause
- [ ] Password hashing uses bcryptjs with 12 rounds
- [ ] All passwords are hashed before DB storage
- [ ] No sensitive data in JWT payload
- [ ] HTTP-only and Secure flags on session cookies
- [ ] CORS configured to allow only your domain
- [ ] Rate limiting implemented on login/registration
- [ ] NEXT_PUBLIC_ENABLE_ROLE_TOGGLE is false
- [ ] Mock user not in production code
- [ ] Mapbox token restrictions configured
- [ ] HTTPS enforced everywhere in production
- [ ] Error messages don't leak sensitive info
- [ ] No console.log of sensitive data
- [ ] Database credentials not in code or logs
- [ ] No SQL injection vulnerabilities
- [ ] XSS protection in place (React escaping + sanitization)
- [ ] CSRF tokens in forms (NextAuth provides this)
- [ ] Dependencies updated and audited
- [ ] npm audit passes with no high/critical issues
- [ ] Build succeeds without security errors
- [ ] Staging environment uses production-like secrets
- [ ] Audit logging configured
- [ ] Error monitoring configured (Sentry, etc.)

### Post-Deployment Checklist
- [ ] Monitor error logs for security issues
- [ ] Review audit logs for suspicious activity
- [ ] Check rate limiting is functioning
- [ ] Verify HTTPS is enforced (check headers)
- [ ] Test authentication flow end-to-end
- [ ] Test role-based access control
- [ ] Test data isolation (worker can't see hirer data)
- [ ] Verify payment processing is secure
- [ ] Test forgot password flow
- [ ] Confirm email verification is working
- [ ] Check response headers for security settings

```bash
# Quick deployment verification:
echo "=== Security Deployment Checklist ==="

# 1. Verify environment variables
echo -e "\n[1] Environment variables:"
[ -n "$NEXTAUTH_SECRET" ] && echo "✓ NEXTAUTH_SECRET set" || echo "✗ MISSING: NEXTAUTH_SECRET"
[ -n "$DATABASE_URL" ] && echo "✓ DATABASE_URL set" || echo "✗ MISSING: DATABASE_URL"
[ -n "$NEXTAUTH_URL" ] && echo "✓ NEXTAUTH_URL set" || echo "✗ MISSING: NEXTAUTH_URL"

# 2. Verify HTTPS
echo -e "\n[2] HTTPS enforcement:"
if [[ "$NEXTAUTH_URL" == https://* ]]; then
  echo "✓ NEXTAUTH_URL uses HTTPS"
else
  echo "✗ ERROR: NEXTAUTH_URL not HTTPS"
fi

# 3. Check no secrets in code
echo -e "\n[3] Secrets exposure check:"
if grep -r "password\|secret\|token" app/ --include="*.ts" --include="*.tsx" | \
   grep -v "process.env\|getServerSession\|user.password" | grep -q "password\|token"; then
  echo "⚠ WARNING: Possible hardcoded secrets"
else
  echo "✓ No obvious hardcoded secrets"
fi

# 4. Verify npm audit
echo -e "\n[4] Dependency security:"
npm audit --audit-level=high 2>/dev/null && echo "✓ npm audit passed" || echo "⚠ npm audit has issues"

echo -e "\n=== Checklist Complete ==="
```

---

## Conclusion

This security audit document covers CrewLink's authentication and authorization architecture. Regularly review and update this document as the application evolves. Conduct penetration testing quarterly and perform security code reviews on all authentication changes.

**Key Principles to Remember:**
1. **Never trust user input** - Always validate and sanitize
2. **Scope every database query** - Every query must filter by authenticated user
3. **Encrypt sensitive data** - Passwords, tokens, payment info
4. **Log security events** - Authentication, authorization, sensitive operations
5. **Test access control** - Verify role and ownership checks on every endpoint
6. **Keep dependencies updated** - Regular npm audit and updates
7. **Use HTTPS everywhere** - Never transmit over HTTP
8. **Monitor in production** - Set up alerts for suspicious activity

For questions or updates to this document, contact the security team.
